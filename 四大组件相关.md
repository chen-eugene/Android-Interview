### 四大组件
##### 1、手动画出Activity、Fragment的生命周期，他们是怎么关联的。

##### 2、Activity常见情形下的生命周期，如按下home键、锁屏。
- Back键：onPause → onSaveInstanceState → onStop → onDestroy
- Home键：onPause → onStop / onRestart → onStart → onResume
- 锁屏： onPause → onSaveInstanceState → onStop / onRestart → onStart → onResume
- A启动B：A：onPause → B：onCreate → B：onStart → B：onResume → A：onSaveInstanceState → A：onStop → A：onDestroy(A是否调用finish)
- 被打断时(如接电话)：onPause → onSaveInstanceState → onStop / onRestart → onStart → onResume
##### 3、	异常情况下Activity的生命周期，如横竖屏切换、系统资源不足。
- 横竖屏切换
Activity被销毁：onPause → onSaveInstanceState(与onPause没有时序关系，可能在之前，也可能在之后) → onStop → onDestroy                  
Activity被重新创建：onCreate → onRestoreInstanceState → onStart → onResume                                                            
当不想Activity被重新创建，则需要在Manifest中添加configChanges属性，在Activity中复写onConfigurationChanged方法。
- 资源内存不足导致低优先级Activity被kill
①前台Activity —— 正在和用户交互的Activity，优先级最高。
②可见但非前台Activity —— 如Activity弹了一个对话框，导致Activity可见但位于后台，无法与用户直接交互。
③后台Activity —— 已经被暂停的Activity，比如执行了onStop，优先级最低。
当系统内存不足时，会按照优先级去杀死Activity，并通过onSaveInstanceState和onRestoreInstanceState来保存和恢复数据。
##### 4、什么时Activity任务栈。
- 是什么：
任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放
启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，Android系统显示的就是前台任务栈中的Top实例Activity。
- 作用：
由于android强化了组件概念，弱化了Aplication的概念，所以在android程序开发中，A应用的A组件想要使用拍照或录像的功能就可以不用去针对Camera类进行开发，直接调用系统自带的摄像头应用（称其B应用）中的组件（称其B组件）就可以了，但是这就引发了一个新问题，A组件运行在A应用中，B组件运行在B应用中，自然都不在同一个进程中，那么从B组件中返回的时候，如何实现正确返回到A组件呢？Task就是来负责实现这个功能的，它是从用户角度来理解应用而建立的一个抽象概念。
##### 5、	Activity启动模式以及使用的场景，对应的Intent Flag。
1. 启动模式
- standard 标准模式（系统默认模式）
每次启动一个Activity都会重新创建一个新的实例。
当用ApplicationContext去启动standard模式的Activity时，会报如下错误![Alt text](./15362154131.png)
这是因为standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context（如ApplicationContext）并没有任务栈。
解决方法就是为Intent添加FLAG_ACTIVITY_NEW_TASK标记，这样启动的时候就会创建一个新的任务栈，相当于singleTask模式。
以standard方式启动的Activity被跨进程调用，在5.0之前新启动的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序，在5.0之后，上述情景会创建一个新的Task，新启动的Activity就会放入刚创建的Task中。

- singleTop 栈顶复用
如果新Activity已经位于任务栈的栈顶，那么Activity不会被重新创建，同时它的onNewIntent方法会被调用。如果新Activity不在栈顶，那么新Activity仍会被重新创建。
应用场景：在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。

- singleTask 栈内复用
当一个具有singleTask模式的Activity被启动后，比如Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例并放入到栈中。如果存在A所需的任务栈，并且存在A的实例，那么系统就会回调A的onNewIntent方法。singleTask具有ClearTop效果，会将位于它以上的Activity实例全部清除出栈。
TaskAffinity属性可以为Activity指定一个任务栈，属性值不能和包名相同，否则就相当于没有指定，因为默认情况下，所有的Activity的任务栈为应用的包名。
当TaskAffinity和singleTask配对使用的时候，待启动的Activity会运行在名字和TaskAffinity形同的任务栈中。

- singleInstance 单实例模式
整个手机系统只有一个实例存在，不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。

2. Intent Flag标识
有两种方式为Activity指定启动模式，1、通过AndroidMenifest，2、通过Intent设置标识来启动。第二种的优先级高于第一种，当两种方式同时存在时，以第二种方式为准。                                                                                                                                 
FLAG_ACTIVITY_NEW_TASK：指定singleTask启动模式。                                                                                         
FLAG_ACTIVITY_SINGLE_TOP：指定singleTop启动模式。                                                                                       
FLAG_ACTIVITY_CLEAR_TOP：当Activity启动时，在统一任务栈中所有位于它上面的Activity都要出栈。一般和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，如果被启动的Activity实例已经存在，系统就会回调onNewIntent方法；如果被启动的Activity采用的时standard模式，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。


