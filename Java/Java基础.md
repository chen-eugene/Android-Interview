#### 1、面向过程、面向对象和面向切面编程的区别和特点。

  - 面向过程：一种以过程为中心的编程思想。以正在发生的为主要目标进行编程。与面向对象的最大区别就是没有面向对象中对象的概念。
    - 优势：性能高于面向对象，因为类调用时需要实例化，开销比较大，比较消耗资源。在单片机、嵌入式开发、Linux/Unix等注重性能领域一般采用面向过程开发。
    - 缺点：没有面向对象易于维护、良好的复用性和易于扩展的优点。
    
  - 面向对象(OOP)：提倡的是将功能模块化，对象化，面向对象把所有的事物都当做对象看待，因此每一个对象都有自己的生命周期，都是一个封装的整体。
    - 优势：每一个对象都有自己的一套垂直的系列方法和属性，使得我们使用对象的时候不需要太多的关系它的内部细节和实现过程，只需要关注输入和输出。
    - 缺点：并不是所有的问题都能够完美的划分到模块中，不可避免的会出现重复代码。
    
  - 面型切面(AOP)：把程序逻辑分解成**关注点**，基于AOP的编程可以让我们横向的切割某一类方法和属性（不需要关心他是什么类别！），提倡的是针对同一类问题的统一处理。这意味着，在 AOP 中，我们不需要显式的修改就可以向代码中添加可执行的代码块。
    - 优势：弥补了OOP的不足，极大程度的降低了重复代码，提高了代码的复用率和开发效率。

#### 2、面向对象的三大特征：封装、继承、多态。
  
  - 封装：把一个对象的属性私有化，只提供一些可以被外界访问的属性的方法。
  - 继承：在已经存在的类的基础上创建新类，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。
  - 多态：引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
    
    实现多态有两种方式：继承和实现接口。
  

#### 3、什么是JDK，什么是JRE，什么是JVM。

  - JDK：给开发者提供的开发工具，它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。
  - JRE：Java运行环境，用于运行java程序。
  - JVM：当运行一个程序时，JVM 负责将字节码转换为特定机器代码。JVM 提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统时的Java具有跨平台的特性。
  
#### 4、字符串字面量和new String()有什么区别。

  - 字符串字面量：String str = “abc”;可能创建一个或者不创建对象，如果”abc”在字符串池中不存在，会在java字符串池中创建一个String对象（”abc”），然后str指向这个内存地址，无论以后用这种方式创建多少个值为”abc”的字符串对象，始终只有一个内存地址被分配。
  - String str = new String(“abc”);至少会创建一个对象，也有可能创建两个。因为用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在”abc”,则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。
 
  
#### 5、	String、StringBuffer和StringBuilder的区别。

  String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响。
  
  StringBuffer、StringBuilder在每次修改的时候是对自身对象进行操作，而不是生成新的对象，再改变对象引用。
  
  在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了StringBuffer对象的拼接，所以这些时候 String 对象的速度并不会比StringBuffer对象慢，而特别是以下的字符串对象生成中。如：                                                                                                       
`String S1 = “This is only a” + “ simple” + “ test” `                                                                                   
但是如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：
``` 
String S2 = “This is only a”;
String S3 = “ simple”;
String S4 = “ test”;
String S1 = S2 +S3 + S4; 
```

  StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此容量，就无需分配新的内部缓冲区数组。

  StringBuilder是Java5新增的一个StringBuffer的替代类，它不是线程安全的。

#### 6、在静态方法中能不能调用非静态的成员变量。（能不能覆盖一个static的方法）
  
  static关键字：在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。
  
  对象的创建是在运行时创建的，而static所修饰的属性和方法是在编译时创建的，所以静态方法不能访问非静态属性，同时也不能覆盖一个static的方法，两者概念都不一样。
  
  简单来说static修饰的成员和方法属于类而不属于对象。
  
#### 7、抽象类和接口的区别。
1.语法层面上的区别

　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。                                                                                 

2.设计层面上的区别

　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

　　2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

#### 8、	equals方法的作用是什么，它和==有什么区别。

  - "=="：作用是判断两个对象的地址是不是相等，即两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）。
  - equals：作用时判断两个对象是否相等。默认情况下，调用的是Object中的equals方法，等价于“==”，即比较两个对象的地址是否相等。通常情况下会覆盖equals方法。
  
#### 9、	hashCode方法的作用是什么，它和equals方法有什么联系。

  - hashCode()：作用是获取哈希码，也叫做散列码。将任意长度的数据映射成一个固定长度的值。
  
    在用到hash进行管理的数据结构中，比如hashmap，hash值存在的目的是加速键值对的查找。
    
  - hash碰撞：对于两个任意的数据，可能生成相同的hash值，但这种的可能性很小。
  
  - hashcode()和equals()：
    - 如果两个对象相等，则hashcode一定也是相同的。
    - 两个对象相等,对两个对象分别调用equals方法都返回true。
    - 两个对象有相同的hashcode值，它们不一定是相等的。
    - 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。
  

  对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。

为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）

也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。

#### 10、可以直接根据hashcode值判断两个对象是否相等吗?

  肯定是不可以的，因为不同的对象可能会生成相同的hashcode值,即所谓的hash碰撞。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。

  - 也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；
  - 如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；
  - 如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；
  - 如果两个对象的hashcode值相等，则equals方法得到的结果未知。

在重写equals方法的同时，必须重写hashCode方法，因为默认情况下，hashCode方法是将对象的存储地址进行映射。

#### 11、fianl关键字的作用。
   
   - 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
   - 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
   - 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

#### [12、什么是序列化，序列化前后对象有何区别。](https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html)

序列化：表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。

  - **虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否相同，更重要的是两个类的序列化 ID 是否相同（serialVersionUID）。**
  - **序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。**
  - 要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。
  - Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
  - 在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作。
  - Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。

#### [13、序列化Serializable和Parcelable的区别。](https://blog.csdn.net/SilenceOO/article/details/73469237)
  
  - Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。
  - Parcelable的性能比Serializable好，因为后者在反射过程频繁GC，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据。
  - Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。
  - Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。

#### [14、try catch finally，try里有return，finally还执行么。](http://www.cnblogs.com/lanxuezaipiao/p/3440471.html#top)
总结：
 - try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。
 - 在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到。
 - finally语句在return语句执行之后return返回之前执行的。
 - finally块中的return语句会覆盖try块中的return返回。
 - 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。
- try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。
- 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。

#### [15、Exception与Error类结构，Exception与Error的区别。(Java异常分类)](https://blog.csdn.net/hguisu/article/details/6155636)
![异常分类](https://github.com/chen-eugene/Interview/blob/master/image/1354020417_5176.jpg)

  - Error：是程序无法处理的错误，表示运行应用程序中较严重问题，如ava虚拟机运行错误（Virtual MachineError）、内存溢出（OutOfMemoryError）等，这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时。 这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。
  
  - Exception（异常）:是程序本身可以处理的异常。
    - 运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。 
    - 非运行时异常 （编译异常）：是RuntimeException以外的异常，如IOException、SQLException，类型上都属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。 

在以下4种特殊情况下，finally块不会被执行：
  - 在finally语句块中发生了异常。
  - 在前面的代码中用了System.exit()退出程序。
  - 程序所在的线程死亡。
  - 关闭CPU。  


