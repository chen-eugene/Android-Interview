#### 1、面向过程、面向对象和面向切面编程的区别和特点。

  - 面向过程：一种以过程为中心的编程思想。以正在发生的为主要目标进行编程。与面向对象的最大区别就是没有面向对象中对象的概念。
    - 优势：性能高于面向对象，因为类调用时需要实例化，开销比较大，比较消耗资源。在单片机、嵌入式开发、Linux/Unix等注重性能领域一般采用面向过程开发。
    - 缺点：没有面向对象易于维护、良好的复用性和易于扩展的优点。
    
  - 面向对象(OOP)：提倡的是将功能模块化，对象化，面向对象把所有的事物都当做对象看待，因此每一个对象都有自己的生命周期，都是一个封装的整体。
    - 优势：每一个对象都有自己的一套垂直的系列方法和属性，使得我们使用对象的时候不需要太多的关系它的内部细节和实现过程，只需要关注输入和输出。
    - 缺点：并不是所有的问题都能够完美的划分到模块中，不可避免的会出现重复代码。
    
  - 面型切面(AOP)：把程序逻辑分解成**关注点**，基于AOP的编程可以让我们横向的切割某一类方法和属性（不需要关心他是什么类别！），提倡的是针对同一类问题的统一处理。这意味着，在 AOP 中，我们不需要显式的修改就可以向代码中添加可执行的代码块。
    - 优势：弥补了OOP的不足，极大程度的降低了重复代码，提高了代码的复用率和开发效率。


##### 1、	equals方法的作用是什么，它和==有什么区别。
equals() 的作用是用来判断两个对象是否相等，Object中定义了equals()方法，所有的类都可以通过equals()去比较两个对象是否相等，默认的“equals()”方法，等价于“==”，即比较两个对象的地址是否相等，因此通常会重写equals()方法。
##### 2、	hashCode方法的作用是什么，它和equals方法有什么联系。
对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。

为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）

也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。

##### 3、可以直接根据hashcode值判断两个对象是否相等吗?
肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。

- 也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；

- 如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；

- 如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；

- 如果两个对象的hashcode值相等，则equals方法得到的结果未知。

在重写equals方法的同时，必须重写hashCode方法，因为默认情况下，hashCode方法是将对象的存储地址进行映射。

##### 4、	抽象类和接口的区别。
1.语法层面上的区别

　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。                                                                                 

2.设计层面上的区别

　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

　　2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
  
##### 5、	什么是面向接口编程，它有什么好处。

##### 6、	String、StringBuffer和StringBuilder的区别。
String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响。
StringBuffer、StringBuilder在每次修改的时候是对自身对象进行操作，而不是生成新的对象，再改变对象引用。
在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了StringBuffer对象的拼接，所以这些时候 String 对象的速度并不会比StringBuffer对象慢，而特别是以下的字符串对象生成中。如：                                                                                                       
`String S1 = “This is only a” + “ simple” + “ test” `                                                                                   
但是如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：
``` 
String S2 = “This is only a”;
String S3 = “ simple”;
String S4 = “ test”;
String S1 = S2 +S3 + S4; 
```

StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此容量，就无需分配新的内部缓冲区数组。

StringBuilder是Java5新增的一个StringBuffer的替代类，它不是线程安全的。

#### [7、什么是序列化，序列化前后对象有何区别。](https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html)
序列化：表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。
- **虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否相同，更重要的是两个类的序列化 ID 是否相同（serialVersionUID）。**
- **序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。**
- 要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。
- Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
- 在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作。
- Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。

#### [8、序列化Serializable和Parcelable的区别。](https://blog.csdn.net/SilenceOO/article/details/73469237)
  
  - Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。
  - Parcelable的性能比Serializable好，因为后者在反射过程频繁GC，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据。
  - Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。
  - Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。

#### [9、try catch finally，try里有return，finally还执行么。](http://www.cnblogs.com/lanxuezaipiao/p/3440471.html#top)
总结：
 - try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。
 - 在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到。
 - finally语句在return语句执行之后return返回之前执行的。
 - finally块中的return语句会覆盖try块中的return返回。
 - 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。
- try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。
- 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。

#### [10、Exception与Error类结构，Exception与Error的区别。(Java异常分类)](https://blog.csdn.net/hguisu/article/details/6155636)
![异常分类](https://github.com/chen-eugene/Interview/blob/master/image/1354020417_5176.jpg)

- Error：是程序无法处理的错误，表示运行应用程序中较严重问题，如ava虚拟机运行错误（Virtual MachineError）、内存溢出（OutOfMemoryError）等，这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时。 
- Exception（异常）:是程序本身可以处理的异常。

  - 运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。 
  - 非运行时异常 （编译异常）：是RuntimeException以外的异常，如IOException、SQLException，类型上都属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。 


