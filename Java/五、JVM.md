#### 1、Java内存模型、堆区和栈区的区别。

Java虚拟机在执行Java程序的过程中会把所管理的内存区域划分成若干个不同的数据区域。

- 程序计数器(Program Counter Register)：可以看作当前线程所执行的字节码的行号指示器。**为线程私有，唯一没有OOM的区域。**

  为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，线程之间互不影响。

- Java虚拟机栈(Java Virtual Machine Stacks)：**线程私有，生命周期与线程相同。**

   虚拟机栈描述的是：**Java方法执行的内存模型**：每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**用于存放**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。线程请求的栈深度大于虚拟机所允许的深度，抛出SOF，动态扩展是无法申请到足够的内存，抛出OOM。     

   虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。
   
   什么是栈帧：栈帧可以理解为一个方法的运行空间。它主要由两部分构成：
     - 一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；
     
     局部变量表存放的是编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型（指向了一条字节码指令的地址）。
     
     - 另一部分是操作数栈，用来存放操作数。
      
     我们知道，Java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可通过存储器或寄存器寻址找到需要的操作数；而 Java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。
   
  线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError（SOF）。
  虚拟机栈扩展时无法申请到足够的内存，抛出OutOfMemoryError（OOM）。   
   
- 本地方法栈(Native Method Stack)：通虚拟机栈相似，虚拟机栈为Java方法服务，本地方法栈为Nativie方法服务，同样会抛出SOF和OOM。

- Java堆(Java Heap)：虚拟机启动时创建，几乎所有的对象实例都存放在这里。

   由于现在垃圾回收器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代，新生代：Eden空间、From Survivor空间和To Survivor空间。如果在堆中没有内存完成实例分配，并且再无法扩展时，会抛出OOM。
   
- 方法区(Method Area，永久带)：**各线程共享内存**，用于存放已经被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。当方法区无法满足内存分配需求时，将抛出OOM。

- 运行时常量池(Runtime Constant Pool)：**是方法区的一部分**，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于**存放编译期生成的各种字面量和符号引用**，这部分内容在类加载以后进入方法区的运行时常量池中。也会抛出OOM。

- 直接内存(Direct Memory)：既不是虚拟机运行时数据区域的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，也会抛出OOM。

**其中程序计数器、虚拟机栈、本地方法栈为线程私有，生命周期与线程的生命周期相同。**

**局部变量、成员变量和类变量（静态变量和常量）的区别：**
  - 局部变量：存在于虚拟机栈的栈帧中，生命周期同方法的生命周期。
  
  当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！
  
  - 成员变量：属于实例的变量，存在与Java堆中，命周期同对象的生命周期。
  
  当程序中new一个对象时，这个对象存在堆中，对象的引用存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！ 
  
  - 类变量：属于类的属性信息，与类的实例无关，多个实例共用一个类变量。生命周期从程序开始到程序终止。
  
  当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！

#### [2、Java对象是怎么创建的（对象的创建过程）。](https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md)

   ![对象创建过程](https://github.com/chen-eugene/Android-Interview/blob/master/image/4564789168761.jpg)
  
  - **① 类加载检查**：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
  
  - **② 分配内存**：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
  
  分配方式有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**
  
  因此，在使用Serial、ParNew等带Compact(整理)过程的收集器时，通常采用指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
  
  ![内存分配策略](https://github.com/chen-eugene/Android-Interview/blob/master/image/5454871315648648.jpg)
  
   **内存分配时的并发问题**：在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
    - **CAS+失败重试**： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
    - **TLAB**： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。
    
  - **初始化零值**：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
  
  - **设置对象头**： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
   
   - **执行init方法**：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。
  
  
#### [3、对象的内存布局。](https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md#32-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80)
   
   在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：**对象头**、**实例数据**和**对齐填充**。
   - 对象头：Hotspot虚拟机的对象头包括两部分信息：
     - 第一部分用于存储对象自身的自身运行时数据（哈希码、GC分代年龄、锁状态标志等等）。
     - 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。
     
   - 实例数据：实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
   
   - 对齐填充：这部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 
   
  
#### [4、怎么访问一个Java对象（访问对象的过程）。](https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md#33-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D)

  目前主流的访问方式有①使用句柄和②直接指针两种：
  - **句柄（引用）**：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； 
  
  - **直接指针**：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
  
  这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
  
#### 5、Java虚拟机怎么判断那些对象是需要进行回收的（JVM怎么判断对象已死）。

判断对象是否存活的方法一般有两种：

- 引用计数算法(Reference Counting)在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1，当引用失效时，计数器的值就减1，任何时刻计数器的值为0的对象就是不可能被使用的对象。 
    引用计数算法的实现简单，判定效率高，但是Java虚拟机并没有采用引用计数算法，最主要的原因是很难解决对象之间相互循环引用的问题。

- 可达性分析算法(Reachability Chain)：基本思想就是通过一系列的被称为“GC Roots”的对象作为起始点，然后开始向下搜索，所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，就表示此对象不可用。
   
   **GC Roots对象主要包括一下几种：**
   - 虚拟机栈(栈帧中的局部变量表)中引用的对象。
   - 方法区中类静态属性引用的对象。
   - 方法区中常量引用的对象。
   - 本地方法栈中JNI（Native 方法）引用的对象。
   
   **对象生存还是死亡：**
   要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()。当对象没有覆盖finalize()，或则finalize()法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
   
   finalize()是对象逃脱死亡命运的最后一次机会，任何一个对象的finalize()只会被系统自动调用一次，GC 将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 
   
#### [6、Java的四种引用，强弱软虚，及其适用的场景。](https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/%E6%90%9E%E5%AE%9AJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95.md#23-%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8)

   - 强引用：只要强引用还存在，垃圾回收器就永远不会回收掉被引用的对象。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
   
   - 软引用(soft Reference)：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
   
   弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
   
   - 弱引用：它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
   
   （LeakCanary的实现原理）弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
   
   - 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

  虚引用主要用来跟踪对象被垃圾回收的活动。
  
  虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

  特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。**

#### [7、什么是引用队列(ReferenceQueue)？（LeakCanary的原理就用到了引用队列。）](https://blog.csdn.net/kaka0509/article/details/73459419)
  
  拿软引用来说，当软引用指向的对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，因此需要一个适当的清除机制，避免大量SoftReference对象带来的OOM。这就需要用到ReferenceQueue。
  ```
  ReferenceQueue queue = new ReferenceQueue();  
  SoftReference ref=new SoftReference(new MyObject(), queue);  
  ```
  当初始化一个软引用时，可以为软引用指定一个引用队列，当ref指向的MyObject对象被垃圾回收器回收的同时，ref对象本身会被放入ReferenceQueue中。也就是说，ReferenceQueue中保存的对象是Reference对象，而这些Reference对象所指向的对象已经被回收。
  
  在任何时候可以通过ReferenceQueue的poll()方法来检查它所关联的非强可及对象被回收是否被回收。
  
  **WeakHashMap和HashMap的区别：**
  weakHashMap的Entry继承了WeakReference，并在创建Entry实例是会调用`super(key，queue)`，所以WeakHashMap的Key是弱引用，而HashMap的Key是强引用。

#### 8、强引用置为null，会不会被回收。

   JVM采用的可达性分析来判断对象是否为可回收的，显然不需要进行手动置null，Java在这方面做了相当大的努力就是为了让程序员不用关心垃圾回收的事情。对于占用空间比较大的对象（比如大数组），推荐在确认不再使用的时候将其值为null，JVM在回收大对象的时候不如小对象来的及时，置为null就能强制在下次GC的时候进行回收。

#### [9、垃圾回收算法和垃圾回收器。](https://lrh1993.gitbooks.io/android_interview_guide/content/java/virtual-machine/Garbage-Collector.html)
   
   - 标记-清除算法(Mark-Sweep)：它主要存在两个不足：① 标记和清除的过程效率都不高；② 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序循行的过程中需要分配较大对象时，无法申请到足够连续的内存而不得不提前触发另一次的垃圾回收动作。
   
   - 复制算法(Copying)：将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
   
     现代的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是“朝生夕死”的，所以不需要按照1：1的比例来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1。
     
     复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象100%存活的极端情况，所以复制算法不适用于老年代。
     
   - 标记-整理算法(Mark-Compact)：标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。
   
   - 分代收集算法(Generational Collection)：根据对象的存活周期一般把Java堆分为新生代和老年代，根据各个区域的特点采用适当的回收算法。
      
      在新生代，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。
      
      在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清除”或“标记-整理”算法来进行回收。
   
  **分代回收算法：**
   
   **JVM中的分代：**
   
   JVM中分为年轻代（Young generation）和老年代(Tenured generation)。
   
   **在HotSpot中，年轻代被分为三个部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1**
   
   这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

   在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
   
   **Minor GC：** 指发生在新生代的垃圾收集动作，该动作非常频繁。       
   **Full GC/Major GC：** 指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。
   
**垃圾回收器：**

   - Serial收集器：年轻代的单线程收集器，采用的是“复制算法”。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
   
     优势： 简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程效率。
     
   - ParNew收集器：ParNew收集器其实就是Serial收集器的多线程版本，默认开启的线程数与CPU的数量相同。是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
   
   - Parallel Scavenge收集器：新生代收集器，使用复制算法，又是并行的多线程收集器。
   
     最大的特点是： Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。
     
     所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。
     
     高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
     
   - Serial Old收集器：Serial收集器的老年代版本，采用的是“标记-整理”算法。
      
     如果在Server模式下，它主要还有两大用途：
         
        - 1.与Parallel Scavenge收集器搭配使用
        - 2.作为CMS收集器的后备预案，在并发收集发生Conurrent Mode Failure使用。
   
   - Parallel Old收集器：Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
   
     **在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器。**
     
   - **CMS（Concurrent Mark Sweep）收集器：老年代垃圾收集器，采用“标记-清除”算法。是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。尽可能地缩短垃圾收集时用户线程的停顿时间。**
   
     CMS收集器是基于“标记-清除”算法实现的，整个过程分为4个步骤：
      
       - 初始标记：只标记一下GC Roots能直接关联到的对象。
       - 并发标记：进行GC Roots Tracing的过程。
       - 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。
       - 并发清除： 整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。
       
     初始标记，重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只标记一下GC Roots能直接关联到的对象，速度很快。并发标记阶段就是 进行GC Roots Tracing的过程。
     
     重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。
       
     整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。
       
   **缺点：**
     - CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。
     - CMS收集器无法处理浮动垃圾，可能出现“Conurrent Mode Failure”失败而导致另一次Full GC的产生。
     - CMS是一款基于“标记-清除”算法实现的收集器，所以会有大量空间碎片问题。
     
  - G1收集器：是一款面向服务端应用的垃圾收集器。
    - 并行与并发：能充分利用多CPU，多核环境下的硬件优势，缩短Stop-The-World停顿的时间，同时可以通过并发的方式让Java程序继续执行。
    - 分代收集：可以不需要其他收集器的配合管理整个堆，但是仍采用不同的方式去处理分代的对象。
    - 空间整合：G1从整体上来看，采用基于“标记-整理”算法实现收集器。G1从局部上来看，采用基于“复制”算法实现。
    - 可预测停顿：整个Java堆划分成为多个大小相等的独立区域。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。
   
   
#### [10、Java类加载机制，类加载分为那几个阶段。](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483934&idx=1&sn=f247f9bee4e240f5e7fac25659da3bff&chksm=fd98547fcaefdd6996e1a7046e03f29df9308bdf82ceeffd111112766ffd3187892700f64b40#rd)
  
  **类加载机制**：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
  
  **Java语言中类型的加载连接以及初始化过程都是在程序运行期间完成的**，这种策略虽然会使类加载时稍微增加一点性能开销，但是增加了Java应用程序的灵活性。
  
  类从被加载到虚拟机内存中开始，到卸载出内存为止，整个过程的生命周期包括一下几个阶段。
  - 加载：获取类的二进制流
    在加载阶段，虚拟机需要做3件事：
    - 通过一个类的全限定名来获取定义此类的二进制字节流（根本没有指明从哪里获取、怎样获取，可以说一个非常开放的平台了）。
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
  
    **注意**：非数组类加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成。（即重写一个类加载器的loadClass（）方法）
  
  - 验证：验证是连接阶段的第一步，目的是为了**确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。**
    
    虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。

    从整体上看，验证阶段大致上会完成4个阶段的校验工作：文件格式、元数据、字节码、符号引用。
  
  - 准备：**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。**（备注：这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中）。
  
  - 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
  
    - 符号引用(Symbolic References)： 符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
    - 直接引用（Direct References）: 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，引用的目标必定已经在内存中存在。
  
  - 初始化
  
    虚拟机规范严格规定了**有且只有**5种情况必须立即对类进行“初始化”：
    - 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外）、已经调用一个类的静态方法的时候。
    - 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。
    - 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。
    - 当虚拟机启动时，用户需要制定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个类。
    - 使用Jdk1.7动态语言支持的时候的一些情况。
    
    **所有引用类的方式都不会触发初始化称为被动引用：**
    - ① 通过子类引用父类静态字段，不会导致子类初始化。
    - ② 通过数组定义引用类，不会触发此类的初始化
    - ③ 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类，因此不会触发定义常量的类的初始化。
  
  - 使用
  - 卸载
  
  加载、验证、准备、初始化和卸载这5个阶段的顺序是固定的，其它几个阶段顺序不一定。
  
  
#### 11、对类加载器有了解吗？

  对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。
  
   从Java虚拟机的角度有两种类加载器：
   - 启动类加载器(Bootstrap ClassLoader)：使用C++语言实现，是Java虚拟机的一部分。
   - 其他类加载器：独立于虚拟机之外，全部继承自java.lang.ClassLoader。
   
   从Java开发人员的角度来看，绝大部分Java程序都会使用到一下3种系统提供的类加载器：
   - 启动类加载器(Bootstrap ClassLoader)
     这个类加载器负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。
   
   - 扩展类加载器（Extension ClassLoader）
     这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
     
   - 应用程序类加载器（Application ClassLoader）
     这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

  **思考一个问题：为什么需要有不同的类加载器，而不只实现一个，采用不同的type进行区分？**
  
   - **① 首先，是为了区分同名的类**：假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。试想，这时候 jvm 该怎么加载这些类同时能尽可能的避免掉类加载时对同名类的差异检测呢？当然是不同的应用都拥有自己独立的类加载器了。
   - **② 其次，是为了更方便的加强类的能力**：类加载器可以在 load class 时对 class 进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及 debug 等原理。怎么样达到仅修改一个类库而不对其他类库产生影响的效果呢？一个比较方便的模式就是每个类库都可以使用独立的类加载器


#### 12、类的加载机制，为什么用双亲委派模型，Java是否支持多态。
  
  如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成（所以所有的加载请求最终都应该传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。

  作用： **使用双亲委派模型，使Java类随着它的类加载器一起具备了一种带有优先级的层次关系。** 例如类java.lang.Object，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序中的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型，由各个类加载器自行去加载，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，应用程序也将会变得一片混乱。
  
  
#### [13、Java值传递和引用传递的区别？](https://juejin.im/post/5bce68226fb9a05ce46a0476)

[值传递、指针传递、引用传递](https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html)
  - 值传递：把参数的实际值复制给函数的形式参数，这种情况下，修改函数内的心是参数对实际参数没有影响。
  - 引用传递：把参数的引用复制给形式参数，在函数内，该引用用于访问调用要用到的实际参数。这种情况下，修改形式参数会影响到实际参数。
  - 指针传递：把参数的地址复制给形式参数，在函数内，该地址用于访问调用要用到的实际参数。这种情况下，修改形式参数会影响到实际参数。
  ```
  public void changeValue(int x){
    x = x * 2;
  }
  
  public void changeRefrence(Person p){
    p.name = "Rose";
  }
  ```
  在Java中只有值传递没有引用传递。
  - 在Java中，如果传入的是基本数据类型，那么传递将是参数的值，所有的操作不会影响到原来的变量。
  - 如果传入的是引用数据类型，那么传递的是变量p中存储的值，p中所存储的是Person对象的地址，所以变量p操作的是传入的地址所指向的内存区域，这个过程看起来好像是引用传递。




































   
   
