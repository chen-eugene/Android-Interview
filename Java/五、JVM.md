#### 1、Java内存模型、堆区和栈区的区别。

Java虚拟机在执行Java程序的过程中会把所管理的内存区域划分成若干个不同的数据区域。

- 程序计数器(Program Counter Register)：可以看作当前线程所执行的字节码的行号指示器。**为线程私有，唯一没有OOM的区域。**

  为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，线程之间互不影响。

- Java虚拟机栈(Java Virtual Machine Stacks)：**线程私有，生命周期与线程相同。**

   虚拟机栈描述的是：**Java方法执行的内存模型**：每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**用于存放**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。线程请求的栈深度大于虚拟机所允许的深度，抛出SOF，动态扩展是无法申请到足够的内存，抛出OOM。     

   虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。
   
   什么是栈帧：栈帧可以理解为一个方法的运行空间。它主要由两部分构成：
     - 一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；
     
     局部变量表存放的是编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型（指向了一条字节码指令的地址）。
     
     - 另一部分是操作数栈，用来存放操作数。
      
     我们知道，Java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可通过存储器或寄存器寻址找到需要的操作数；而 Java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。
   
  线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError（SOF）。
  虚拟机栈扩展时无法申请到足够的内存，抛出OutOfMemoryError（OOM）。   
   
- 本地方法栈(Native Method Stack)：通虚拟机栈相似，虚拟机栈为Java方法服务，本地方法栈为Nativie方法服务，同样会抛出SOF和OOM。

- Java堆(Java Heap)：虚拟机启动时创建，几乎所有的对象实例都存放在这里。

   由于现在垃圾回收器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代，新生代：Eden空间、From Survivor空间和To Survivor空间。如果在堆中没有内存完成实例分配，并且再无法扩展时，会抛出OOM。
   
- 方法区(Method Area，永久带)：**各线程共享内存**，用于存放已经被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。当方法区无法满足内存分配需求时，将抛出OOM。

- 运行时常量池(Runtime Constant Pool)：**是方法区的一部分**，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于**存放编译期生成的各种字面量和符号引用**，这部分内容在类加载以后进入方法区的运行时常量池中。也会抛出OOM。

- 直接内存(Direct Memory)：既不是虚拟机运行时数据区域的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，也会抛出OOM。

**其中程序计数器、虚拟机栈、本地方法栈为线程私有，生命周期与线程的生命周期相同。**

局部变量、成员变量和类变量（静态变量和常量）的区别：
  - 局部变量：存在于虚拟机栈的栈帧中，生命周期同方法的生命周期。
  
  当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！
  
  - 成员变量：属于实例的变量，存在与Java堆中，命周期同对象的生命周期。
  
  当程序中new一个对象时，这个对象存在堆中，对象的引用存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！ 
  
  - 类变量：属于类的属性信息，与类的实例无关，多个实例共用一个类变量。生命周期从程序开始到程序终止。
  
  当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！

#### 2、Java对象是怎么创建的（对象的创建过程）。

   

#### 2、Java虚拟机怎么判断那些对象是需要进行回收的（JVM怎么判断对象已死）。

判断对象是否存活的方法一般有两种：

- 引用计数算法(Reference Counting)在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1，当引用失效时，计数器的值就减1，任何时刻计数器的值为0的对象就是不可能被使用的对象。 
    引用计数算法的实现简单，判定效率高，但是Java虚拟机并没有采用引用计数算法，最主要的原因是很难解决对象之间相互循环引用的问题。

- 可达性分析算法(Reachability Chain)：基本思想就是通过一系列的被称为“GC Roots”的对象作为起始点，然后开始向下搜索，所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，就表示此对象不可用。
   
   **GC Roots对象主要包括一下几种：**
   - 虚拟机栈(栈帧中的局部变量表)中引用的对象。
   - 方法区中类静态属性引用的对象。
   - 方法区中常量引用的对象。
   - 本地方法栈中JNI（Native 方法）引用的对象。
   
   **对象生存还是死亡：**
   要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()。当对象没有覆盖finalize()，或则finalize()法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
   
   finalize()是对象逃脱死亡命运的最后一次机会，任何一个对象的finalize()只会被系统自动调用一次，GC 将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 
   
#### 3、Java的四种引用，强弱软虚，及其适用的场景。

   - 强引用：只要强引用还存在，垃圾回收器就永远不会回收掉被引用的对象。
   - 软引用(soft Reference)：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
   - 它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
   - 虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

#### 4、强引用置为null，会不会被回收。

   JVM采用的可达性分析来判断对象是否为可回收的，显然不需要进行手动置null，Java在这方面做了相当大的努力就是为了让程序员不用关心垃圾回收的事情。对于占用空间比较大的对象（比如大数组），推荐在确认不再使用的时候将其值为null，JVM在回收大对象的时候不如小对象来的及时，置为null就能强制在下次GC的时候进行回收。

#### 5、垃圾回收算法和垃圾回收器。
   
   - 标记-清除算法(Mark-Sweep)：它主要存在两个不足：① 标记和清除的过程效率都不高；② 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序循行的过程中需要分配较大对象时，无法申请到足够连续的内存而不得不提前触发另一次的垃圾回收动作。
   
   - 复制算法(Copying)：将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
   
     现代的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是“朝生夕死”的，所以不需要按照1：1的比例来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1。
     
     复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象100%存活的极端情况，所以复制算法不适用于老年代。
     
   - 标记-整理算法(Mark-Compact)：标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。
   
   - 分代收集算法(Generational Collection)：根据对象的存活周期一般把Java堆分为新生代和老年代，根据各个区域的特点采用适当的回收算法。
      
      在新生代，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。
      
      在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清除”或“标记-整理”算法来进行回收。
   
  **分代回收算法：**
   
   **JVM中的分代：**
   
   JVM中分为年轻代（Young generation）和老年代(Tenured generation)。
   
   **在HotSpot中，年轻代被分为三个部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1**
   
   这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

   在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
   
   **Minor GC：** 指发生在新生代的垃圾收集动作，该动作非常频繁。       
   **Full GC/Major GC：** 指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。
   
**垃圾回收器：**

   - Serial收集器：年轻代的单线程收集器，采用的是“复制算法”。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
   
     优势： 简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程效率。
     
   - ParNew收集器：ParNew收集器其实就是Serial收集器的多线程版本，默认开启的线程数与CPU的数量相同。是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
   
   - Parallel Scavenge收集器：新生代收集器，使用复制算法，又是并行的多线程收集器。
   
     最大的特点是： Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。
     
     所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。
     
     高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
     
   - Serial Old收集器：Serial收集器的老年代版本，采用的是“标记-整理”算法。
      
     如果在Server模式下，它主要还有两大用途：
         
        - 1.与Parallel Scavenge收集器搭配使用
        - 2.作为CMS收集器的后备预案，在并发收集发生Conurrent Mode Failure使用。
   
   - Parallel Old收集器：Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
   
     **在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器。**
     
   - **CMS（Concurrent Mark Sweep）收集器：老年代垃圾收集器，采用“标记-清除”算法。是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。尽可能地缩短垃圾收集时用户线程的停顿时间。**
   
     CMS收集器是基于“标记-清除”算法实现的，整个过程分为4个步骤：
      
       - 初始标记：只标记一下GC Roots能直接关联到的对象。
       - 并发标记：进行GC Roots Tracing的过程。
       - 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。
       - 并发清除： 整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。
       
     初始标记，重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只标记一下GC Roots能直接关联到的对象，速度很快。并发标记阶段就是 进行GC Roots Tracing的过程。
     
     重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。
       
     整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。
       
   **缺点：**
     - CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。
     - CMS收集器无法处理浮动垃圾，可能出现“Conurrent Mode Failure”失败而导致另一次Full GC的产生。
     - CMS是一款基于“标记-清除”算法实现的收集器，所以会有大量空间碎片问题。
     
  - G1收集器：是一款面向服务端应用的垃圾收集器。
    - 并行与并发：能充分利用多CPU，多核环境下的硬件优势，缩短Stop-The-World停顿的时间，同时可以通过并发的方式让Java程序继续执行。
    - 分代收集：可以不需要其他收集器的配合管理整个堆，但是仍采用不同的方式去处理分代的对象。
    - 空间整合：G1从整体上来看，采用基于“标记-整理”算法实现收集器。G1从局部上来看，采用基于“复制”算法实现。
    - 可预测停顿：整个Java堆划分成为多个大小相等的独立区域。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。
   
     
   
   






































   
   
