#### [1、什么是线程，什么是进程，能不能只用进程。](https://segmentfault.com/a/1190000005884656)
  - 进程（Process）：是系统进行资源分配和调度的基本单位，是操作系统结构的基础。一个进程可以看作一个程序或者一个应用    
  - 线程(thread)：是程序执行的最小单元。线程是在进程中执行的一个任务。

引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。

区别：
  - 1. 地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
  - 2. 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
  - 3. 调度和切换：线程上下文切换比进程上下文切换要快得多。
  - 4. 在多线程OS中，进程不是一个可执行的实体。
  
#### 2、多线程编程的好处是什么。

  多个线程被并发的执行可以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。线程的创建只需要较少的资源，因此创建多个线程去执行任务比创建多个进程更好。
  
#### 6、一个线程包含了哪些状态。

![线程状态](https://github.com/chen-eugene/Interview/blob/master/image/061046391107893.jpg)

  - 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。
  - 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。
  - 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu时间片，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 时间片转到运行(running)状态。阻塞的情况分三种： 
    - ① 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 
    - ② 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 
    - ③ 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
  - 死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。
  
#### 3、什么是线程安全，Vector是线程安全的吗。
  如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。

#### 4、wait()和sleep()的区别。
- sleep：让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。
- wait：wait方法会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限。
- yield：调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。
  注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。
- join：调用join方法是调用了Object的wait方法，由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。

#### 4、如何停止一个线程。

  ![线程状态](https://github.com/chen-eugene/Interview/blob/master/image/db150002205d9bc30b8f.jpg)
  
  早期的jdk版本中提供了退出的方法：hread.stop, Thread.suspend, Thread.resume和Runtime.runFinalizersOnExit ，因为操作不安全，可能会出现不可控的结果，已不推荐使用。
  
  - ① 等线程自己执行完结束（这种最优雅，但是也没有讨论的意义了）。
  
  - ② 调用中断方法，判断中断标识。但是waiting状态下会抛异常，不能算作优雅。
  
 intercept：单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。直接调用interrupt方法不能中断正在运行中的线程。
  
```
public class Test {
     
    public static void main(String[] args) throws IOException  {
        Test test = new Test();
        MyThread thread = test.new MyThread();
        thread.start();
        try {
            Thread.currentThread().sleep(2000);
        } catch (InterruptedException e) {
             
        }
        thread.interrupt();
    } 
     
    class MyThread extends Thread{
        @Override
        public void run() {
            int i = 0;
            while(!isInterrupted() && i<Integer.MAX_VALUE){
                System.out.println(i+" while循环");
                i++;
            }
        }
    }
}
```
  - ③ 自己加中断状态标识。
    - waiting状态：此状态下退出只能调用中断方法。
    - blocked状态：分两种，一种可中断，调用中断方法退出；一种不可中断，只能等running后退出。
    - ready状态：等cpu调度，不可干预。
    - running状态：自己加共享状态标识。
  
 ```
 private volatile boolean exit = false;
 
 public void run(){
   //先判断状态
   try{
     while(!exit && !Thread.currentThread().isInterrupted()){
      System.out.prinln("running...");
      Thread.sleep(1000);
     }
   }catch(InterruptedException e){
    //中断了
   }finally{
    //退出后记得释放资源
   }
 }  
 ```

#### 5、什么是守护线程。
setDaemon和isDaemon用来设置线程是否成为守护线程和判断线程是否是守护线程。

守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。

#### 7、 线程同步的方法。
在Java中，提供了两种方式来实现同步互斥访问：synchronized和Lock。

**每一个对象都拥有一个锁标记（monitor），也称为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。**

synchronized：
- 当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。

- 当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，

- 如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。

**每个类也会有一个锁，它可以用来控制对static数据成员的并发访问。**

如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。
```
public class Test {
 
    public static void main(String[] args)  {
        final InsertData insertData = new InsertData();
        new Thread(){
            @Override
            public void run() {
                insertData.insert();
            }
        }.start(); 
        new Thread(){
            @Override
            public void run() {
                insertData.insert1();
            }
        }.start();
    }  
}
 
class InsertData { 
    public synchronized void insert(){
        System.out.println("执行insert");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("执行insert完毕");
    }
     
    public synchronized static void insert1() {
        System.out.println("执行insert1");
        System.out.println("执行insert1完毕");
    }
}
```

**对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。**

lock：
-  Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；

- Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。
-  Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

- synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

- Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

- 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

- Lock可以提高多个线程进行读操作的效率。采用synchronized关键字来实现同步的话，就会导致一个问题：

   如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。

  因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。

**在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。**

#### 8、	Java中volatile变量是什么。
- 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
- 可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
- 有序性：即程序执行的顺序按照代码的先后顺序执行。
- 指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

 处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。
指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。

**要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。**

volatile：一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（保证可见性）
- 禁止进行指令重排序。（一定程度上保证有序性）

 volatile关键字禁止指令重排序有两层意思：
 - 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

 - 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

```
x = 2;        //语句1
y = 0;        //语句2
volatile flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```
　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。

　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。
　　
**volatile能够保证程序的可见性，在一定程度上保证有序性，但不能保证程序的原子性。**

使用volatile必须具备以下2个条件：

- 对变量的写操作不依赖于当前值

- 该变量没有包含在具有其他变量的不变式中

#### 9、ThreadLocal是什么。
ThreadLocal叫做线程本地变量，ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，竞争条件被彻底消除了。
- 实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；

- threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量。

#### [10、Java锁的分类。](https://www.cnblogs.com/qifengshi/p/6831055.html)
- **公平锁**：多个线程按照申请锁的顺序来获取锁。           
- **非公平锁**：多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

   ReentrantLock：默认是非公平锁，可以通过构造函数参数设置成公平锁。
Synchronized：是一种非公平锁。


- **可重入锁**：同一个线程在访问某个对象加锁的方法时获取了该对象的锁，在访问这个过程中又去访问其他加锁的方法，将会自动获取锁。

  synchronized和ReentrantLock都是可重入锁。    
                          
                          
- **独享锁**：指该锁一次只能被一个线程所持有。
- **共享锁**：指该锁可被多个线程所持有。

  ReentrantLock和Synchronized都是独享锁，ReadWriteLock的读锁是共享锁，写锁是独享锁。

- **互斥锁/读写锁**：独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。

  互斥锁在Java中的具体实现就是ReentrantLock，Synchronized。
  读写锁在Java中的具体实现就是ReadWriteLock。

- **乐观锁/悲观锁**：乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。

   悲观锁：对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
乐观锁：对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

  悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景。

- **分段锁**：分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
 
#### 11、Java中的线程池有几种。
- 核心线程数量：默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当。

- 最大线程数：表示在线程池中最多能创建多少个线程。

- keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。
  
  默认情况下只作用于最大线程，直到线程池中的线程数不大于corePoolSize，核心线程将会一直存在。
  但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0。
 
   **Java通过Executors提供四种线程池**
   
- newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；

- newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；

- newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。
- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
  
  ![线程池结构图](https://github.com/chen-eugene/Interview/blob/master/image/20170406230435886.jpg)
  
  #### 12、如果提交任务时，线程池队列已满，会发生什么。
当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：
- ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。（默认的拒绝策略）
- ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。
- ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。

#### 13、有三个线程T1，T2，T3，怎么确保它们按顺序执行？
可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。
