##### 1、Java内存模型、堆区和栈区的区别。
Java虚拟机在执行Java程序的过程中会把所管理的内存区域划分成若干个不同的数据区域。
- 程序计数器(Program Counter Register)：可以看作当前线程所执行的字节码的行号指示器。为线程私有，唯一没有OOM的区域。
- Java虚拟机栈(Java Virtual Machine Stacks)：线程私有，生命周期与线程相同。虚拟机栈是描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存放局部变量表、操作数栈、动态链接、方法出口等信息。线程请求的栈深度大于虚拟机所允许的深度，抛出SOF，动态扩展是无法申请到足够的内存，抛出OOM。     

   虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。
   
   什么是栈帧：栈帧可以理解为一个方法的运行空间。它主要由两部分构成，一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；另一部分是操作数栈，用来存放操作数。我们知道，Java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可通过存储器或寄存器寻址找到需要的操作数；而 Java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。
- 本地方法栈(Native Method Stack)：通虚拟机栈相似，虚拟机栈为Java方法服务，本地方法栈为Nativie方法服务，同样会抛出SOF和OOM。
- Java堆(Java Heap)：虚拟机启动时创建，几乎所有的对象实例都存放在这里。

   由于现在垃圾回收器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代，新生代：Eden空间、From Survivor空间和To Survivor空间。如果在堆中没有内存完成实例分配，并且再无法扩展时，会抛出OOM。
- 方法区(Method Area)：共享内存，用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OOM。
- 运行时常量池(Runtime Constant Pool)：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载以后进入方法区的运行时常量池中。也会抛出OOM。
- 直接内存(Direct Memory)：既不是虚拟机运行时数据区域的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，也会抛出OOM。

其中程序计数器、虚拟机栈、本地方法栈为线程私有，生命周期与线程的生命周期相同。
