##### 1、Java内存模型、堆区和栈区的区别。
Java虚拟机在执行Java程序的过程中会把所管理的内存区域划分成若干个不同的数据区域。
- 程序计数器(Program Counter Register)：可以看作当前线程所执行的字节码的行号指示器。为线程私有，唯一没有OOM的区域。
- Java虚拟机栈(Java Virtual Machine Stacks)：线程私有，生命周期与线程相同。虚拟机栈是描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存放局部变量表、操作数栈、动态链接、方法出口等信息。线程请求的栈深度大于虚拟机所允许的深度，抛出SOF，动态扩展是无法申请到足够的内存，抛出OOM。     

   虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。
   
   什么是栈帧：栈帧可以理解为一个方法的运行空间。它主要由两部分构成，一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；另一部分是操作数栈，用来存放操作数。我们知道，Java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可通过存储器或寄存器寻址找到需要的操作数；而 Java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。
- 本地方法栈(Native Method Stack)：通虚拟机栈相似，虚拟机栈为Java方法服务，本地方法栈为Nativie方法服务，同样会抛出SOF和OOM。
- Java堆(Java Heap)：虚拟机启动时创建，几乎所有的对象实例都存放在这里。

   由于现在垃圾回收器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代，新生代：Eden空间、From Survivor空间和To Survivor空间。如果在堆中没有内存完成实例分配，并且再无法扩展时，会抛出OOM。
- 方法区(Method Area，永久带)：各线程共享内存，用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OOM。
- 运行时常量池(Runtime Constant Pool)：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载以后进入方法区的运行时常量池中。也会抛出OOM。
- 直接内存(Direct Memory)：既不是虚拟机运行时数据区域的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，也会抛出OOM。

其中程序计数器、虚拟机栈、本地方法栈为线程私有，生命周期与线程的生命周期相同。
##### 2、Java虚拟机怎么判断那些对象是需要进行回收的。
判断对象是否存活的方法一般有两种：
- 引用计数算法(Reference Counting)在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1，当引用失效时，计数器的值就减1，任何时刻计数器的值为0的对象就是不可能被使用的对象。 
    引用计数算法的实现简单，判定效率高，但是Java虚拟机并没有采用引用计数算法，最主要的原因是很难解决对象之间相互循环引用的问题。

- 可达性分析算法(Reachability Chain)：基本思想就是通过一系列的被称为“GC Roots”的对象作为起始点，然后开始向下搜索，所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，就表示此对象不可用。
   
   GC Roots对象主要包括一下几种：
   - 虚拟机栈(栈帧中的局部变量表)中引用的对象。
   - 方法区中类静态属性引用的对象。
   - 方法区中常量引用的对象。
   - 本地方法栈中JNI（Native 方法）引用的对象。
   
   **对象生存还是死亡：**
   要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()。当对象没有覆盖finalize()，或则finalize()法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
   
   finalize()是对象逃脱死亡命运的最后一次机会，任何一个对象的finalize()只会被系统自动调用一次，GC 将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 
   
#### 3、Java的四种引用，强弱软虚，及其适用的场景。

   - 强引用：只要强引用还存在，垃圾回收器就永远不会回收掉被引用的对象。
   - 软引用(soft Reference)：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
   - 它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
   - 虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

#### 4、强引用置为null，会不会被回收。

   JVM采用的可达性分析来判断对象是否为可回收的，显然不需要进行手动置null，Java在这方面做了相当大的努力就是为了让程序员不用关心垃圾回收的事情。对于占用空间比较大的对象（比如大数组），推荐在确认不再使用的时候将其值为null，JVM在回收大对象的时候不如小对象来的及时，置为null就能强制在下次GC的时候进行回收。

#### 5、垃圾回收算法和垃圾回收器。
   
   - 标记-清除算法(Mark-Sweep)：它主要存在两个不足：① 标记和清除的过程效率都不高；② 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序循行的过程中需要分配较大对象时，无法申请到足够连续的内存而不得不提前触发另一次的垃圾回收动作。
   
   - 复制算法(Copying)：将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
   
     现代的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是“朝生夕死”的，所以不需要按照1：1的比例来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1。
     
     复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象100%存活的极端情况，所以复制算法不适用于老年代。
     
   - 标记-整理算法(Mark-Compact)：标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。
   
   - 分代收集算法(Generational Collection)：根据对象的存活周期一般把Java堆分为新生代和老年代，根据各个区域的特点采用适当的回收算法。
      
      在新生代，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。
      
      在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清除”或“标记-整理”算法来进行回收。
   
  **分代回收算法：**
   
   **JVM中的分代：**
   
   JVM中分为年轻代（Young generation）和老年代(Tenured generation)。
   
   **在HotSpot中，年轻代被分为三个部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1**
   
   这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

   在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
   
   **Minor GC：**指发生在新生代的垃圾收集动作，该动作非常频繁。
   **Full GC/Major GC：**指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。
   








   
   
