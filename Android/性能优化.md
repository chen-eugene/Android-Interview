#### 1、如何进行屏幕适配。
- [常见屏幕适配方案](https://www.jianshu.com/p/55e0fca23b4f)
- [今日头条屏幕适配方案](https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA)

#### 2、ANR原理（回答主线程阻塞5秒不算，要分析源码）。
[ANR原理分析](http://gityuan.com/2016/07/02/android-anr/)
ANR(Application Not responding)，是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。    

 造成ANR的场景：
- Service Timeout:服务在20s内未执行完成；
- BroadcastQueue Timeout：比如前台广播在10s内执行完成
- ContentProvider Timeout：内容提供者执行超时
- InputDispatching Timeout: 输入事件分发超时5s，包括按键分发事件的超时。

#### 3、Java的四种引用，强弱软虚，及其适用的场景。
- 强引用：
   - 强引用可以直接访问目标对象。
   - 强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。
   - 强引用可能导致内存泄露。
- 软引用：
  - 在OutOfMemory异常发生之前，被占用的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。
  - 需要注意的是，在垃圾回收器对这个Java对象回收前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该Java对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。     
  
  - 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。
  - 还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。

- 弱引用：在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。但是，由于垃圾回收器的线程通常优先级很低，因此，并一不定能很快的发现持有弱引用的对象。这种情况下，弱引用对象可以存在较长的一段时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个注册引用队列中。 

  实际应用：播放器的播放Panel，是一个View，就是在视频播放时，可以show、hide, 也可以拖拽进度条之类，还有上面的音量，亮度调节等。这样一个view，我们用弱引用，因为在视频播放过程中，不论硬解还是软解，都将占用大量内存。

-  虚引用：
   - 虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。
   - 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，奖这个虚引用加入引用队列。
   
#### 4、常见的Android内存泄漏的场景，怎么解决。
- 单例造成的内存泄露。
- 匿名内部类/非静态内部类和异步线程。
```
	public class MainActivity extends AppCompatActivity {

        private static TestResource mResource = null;

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            if (mManager == null) {
                mManager = new TestResource();
            }
            //...
        }

        class TestResource {
            //...
        }
    }
```
   每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。

   正确的做法为：将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例。

- 匿名内部类：android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露。
- Handler 造成的内存泄漏。
- 集合类泄漏。

#### 5、怎么减小APK大小。
- 开启minifyEnable混淆代码。
- 开启shrinkResources去除无用资源。
- 删除未使用的xml和图片：使用Lint分析工具。
- 删除未使用的代码：使用Lint分析工具。
- 使用vector矢量图。
- 使用shape作为背景。
- 使用Tiny压缩图片。
- 配置resConfigs：如果APP支持中文`resConfigs "zh"`。
- 使用微信Android资源混淆工具。

#### 6、如何解决卡顿问题。
常见问题：
  - 过度绘制，层级过深。
  - 主线程耗时大的函数、滑动过程中的CPU工作问题。
   
    主线程里占用CUP时间很长的函数，特别关注IO操作（文件IO、网络IO、数据库操作等），
    主线程调用次数多的函数

工具：
  - Profile GPU Rendering（Profile GPU Rendering）
  - 设备过渡绘制查看功能、HierarchyViewer等
  - Lint静态代码分析工具
  - Traceview

#### 8、Android UI卡顿怎么进行监测。
 - [卡顿监测原理](https://blog.csdn.net/lmj623565791/article/details/58626355)     
 - [BlockCanary原理](http://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/)
 
 #### 8、Android UI卡顿怎么进行监测。
[卡顿监测原理](https://blog.csdn.net/lmj623565791/article/details/58626355)
[BlockCanary原理](http://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/)

1. 利用UI线程Looper打印的日志。
  - UI线程中的Looper，在其loop方法中会不断取出Message，调用其绑定的Handler在UI线程进行执行。
```
public static void loop() {
    final Looper me = myLooper();

    final MessageQueue queue = me.mQueue;
    // ...
    for (;;) {
        Message msg = queue.next(); // might block
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " +
                    msg.callback + ": " + msg.what);
        }
        // focus
        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }

        // ...
        }
        msg.recycleUnchecked();
    }
}
```
如果设置了logging，会分别打印出>>>>> Dispatching to和<<<<< Finished to这样的log。
```
public class BlockDetectByPrinter {

    public static void start() {

        Looper.getMainLooper().setMessageLogging(new Printer() {

            private long startTime;   
	    private long blockThreshold;
	    private long startedPrinting;

            @Override
            public void println(String x) {
                if (!startedPrinting) {
        		mStartTimeMillis = System.currentTimeMillis();
       			startedPrinting = SystemClock.currentThreadTimeMillis();
       			mStartedPrinting = true;
   		 } else {
        		final long endTime = System.currentTimeMillis();
        		startedPrinting = false;
			//判断是否为卡顿
       			if (isBlock(endTime)) {
			    StringBuilder sb = new StringBuilder();
        		    StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();
           			 for (StackTraceElement s : stackTrace) {
              				sb.append(s.toString() + "\n");
          			 }
       			}
    		}
            }
        });
    }
    
    private boolean isBlock(long endTime) {
   	 return endTime - startTime > blockThreshold;
    }
    
}
```
可以通过 `Looper.getMainLooper().setMessageLogging(mainLooperPrinter);`
并在mainLooperPrinter中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息。

#### 9、OOM能不能用try catch捕获。
OOM(OutOfMemeryError)属于Error，只有在一种情况下可以捕获OOM，只有在确认并OOM是由try语句中的对象声明导致的，那么在catch语句中，可以释放掉这些对象，解决OOM的问题，继续执行剩余语句。

#### 10、OOM遇到过哪些情况，如何解决的。
[美团OOM案例详细分析](https://tech.meituan.com/oom_analysis.html)     
[Handler造成的OOM分析](http://www.chenwenguan.com/android-oom-analysis/)

OOM类型：
 - Java堆溢出(java.lang.OutOfMemoryError: Java heap space)：一般通过内存映像分析工具MAT(Eclipse Memory Analyzer)对dump出来的HPROF文件进行分析，确认是内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。
 
   - 内存泄漏(Memory Leak)：分析GC Roots引用链，定位出内存泄漏的代码。
   - 内存溢出(Memory Overflow)：从代码上检查某些对象的生命周期过长、持有状态时间过长。

 - 虚拟机栈和本地方法栈溢出
 
 - 方法区和运行时常量池溢出
 
 - 本机直接内存溢出


常见的OOM场景：
- Adapter没使用缓存的convertView。
- Bitmap没有及时回收，调用recycle()函数并不能立即释放Bitmap，读取Bitmap到内存的时候没有做采样率的设置。
- 线程数超限，proc/pid/status中记录的线程数超过proc/sys/kernel/threads-max中规定的最大线程数，场景如随意创建线程，没有使用线程池来管理。
- 广播注册之后没有进行注销。
- WebView没有销毁，应该调用destroy()函数去销毁。
- Handler使用不当导致。

#### 11、Bitmap使用的时候注意什么（Bitmap优化）。

**基础知识：**
- Options.inPreferredConfig修改图片编码格式：
 
  Bitmap.Config ALPHA_8          每个像素占用1 bit (8位)内存  
  Bitmap.Config ARGB_4444        每个像素占用2 bit (16位)内存       
  Bitmap.Config ARGB_8888        每个像素占用4 bit (32位)内存       
  Bitmap.Config RGB_565          每个像素占用2 bit (16位)内存  

- 获取Bitmap大小：

 **加载一张本地资源图片，那么它占用的内存 = width * height * nTargetDensity/inDensity * nTargetDensity/inDensity * 一个像素所占的内存。**

 以1024 * 594的图片为例：
 ```
        // 不做处理，默认缩放。
        BitmapFactory.Options options = new BitmapFactory.Options();
        Bitmap bmp01 = BitmapFactory.decodeResource(getResources(), R.mipmap.bmp, options);
        
        int size01Allocation = bmp01.getAllocationByteCount();
        int size01 = bmp01.getByteCount();

        // 手动设置inDensity与inTargetDensity，影响缩放比例。
        BitmapFactory.Options options_setParams = new BitmapFactory.Options();
        options_setParams.inDensity = 320;
        options_setParams.inTargetDensity = 320;

        Bitmap bmp02 = BitmapFactory.decodeResource(getResources(), R.mipmap.bmp, options_setParams);

        int size02Allocation = bmp02.getAllocationByteCount();
        int size02 = bmp02.getByteCount();
 ```
 xhdpi的文件夹下，inDensity为320，inTargetDensity为440，内存大小为4601344；而4601344 = 1024 * 594 * （440 / 320）* （440 / 320）* 4

 手动设置inDensity与inTargetDensity，使其比例为1，内存大小为2433024；2433024 = 1024 * 594 * 1 * 1 * 4。

 **除了加载本地资源文件的解码方法会默认使用资源所处文件夹对应密度和手机系统密度进行缩放之外，别的解码方法默认都不会。此时Bitmap默认占用的内存 = width * height * 一个像素所占的内存。**
 
**优化策略：**
 - 使用setImageBitmap、setImageResource、BitmapFactory.decodeResource这些函数在完成decode后，最终都是通过java层的createBitmap来完成的，需要消耗更多内存，而BitmapFactory.decodeStream方法则是通过JNI来创建Bitmap，更节约内存。
```
InputStream is = getResources().openRawResource(R.drawable.pic);  
Bitmap bitmap = BitmapFactory.decodeStream(is);
```
 
- 对图片进行压缩显示，按需分配内内存。
 
   - 对图片进行质量压缩。bitmap.compress
   - 对图片进行尺寸缩放。Bitmap.Options.inSampleSize
   - 使用三方库对图片进行压缩。libjpeg

- 使用LruCache和DiskLruCache做内存和磁盘缓存。

- Bitmap进行复用：Android 3.0之前Bitmap.recycle，3.0之后进行复用。

- 使用WeakReference，保证资源能够被及时回收。

#### 12、Bitmap recycler相关（Bitmap如何进行复用）
Google 官方教程 [Managing Bitmap Memory](https://developer.android.com/topic/performance/graphics/manage-memory) 是这样说的

Android2.2（API 8）一下的时候，当 GC 工作时，应用的线程会暂停工作，同步的 GC 会影响性能。而 Android2.3 之后，GC 变成了并发的，意味着 Bitmap 没有引用的时候其占有的内存会很快被回收。

在Android2.3.3（API10）之前，Bitmap 的像素数据存放在 Native 内存，而 Bitmap 对象本身则存放在 Dalvik Heap 中。Native 内存中的像素数据以不可预测的方式进行同步回收，有可能会导致内存升高甚至 OOM Crash。而在 Android3.0 之后，Bitmap 的像素数据也被放在了 Dalvik Heap 中。

Android2.3.3 及以下：使用Bitmap#recycle方法进行内存回收。

Android3.0 及以上使用Bitmap复用。

**Bitmap复用：**
- 被复用的 Bitmap 必须设置inMutable为true（通过 BitmapFactory.Options 设置。
- Android4.4(API 19)之前只有格式为jpg、png，同等宽高（要求苛刻），inSampleSize为1的Bitmap才可以复用。
- Android4.4(API 19)之前被复用的Bitmap的inPreferredConfig会覆盖待分配内存的Bitmap设置的inPreferredConfig。
- Android4.4(API 19)之前待加载Bitmap的Options.inSampleSize必须明确指定为1。
- Android4.4(API 19)之后被复用的Bitmap的内存必须大于需要申请内存的Bitmap的内存。

```
BitmapFactory.Options options = new BitmapFactory.Options();
// 图片复用，这个属性必须设置；
options.inMutable = true;
// 手动设置缩放比例，使其取整数，方便计算、观察数据；
options.inDensity = 320;
options.inTargetDensity = 320;
Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.resbitmap, options);
// 对象内存地址；
Log.i(TAG, "bitmap = " + bitmap);
Log.i(TAG, "bitmap：ByteCount = " + bitmap.getByteCount() + ":::bitmap：AllocationByteCount = " + bitmap.getAllocationByteCount());

// 使用inBitmap属性，这个属性必须设置；
options.inBitmap = bitmap;
options.inDensity = 320;
// 设置缩放宽高为原始宽高一半；
options.inTargetDensity = 160;
options.inMutable = true;
Bitmap bitmapReuse = BitmapFactory.decodeResource(getResources(), R.drawable.resbitmap_reuse, options);
// 复用对象的内存地址；
Log.i(TAG, "bitmapReuse = " + bitmapReuse);
Log.i(TAG, "bitmap：ByteCount = " + bitmap.getByteCount() + ":::bitmap：AllocationByteCount = " + bitmap.getAllocationByteCount());
Log.i(TAG, "bitmapReuse：ByteCount = " + bitmapReuse.getByteCount() + ":::bitmapReuse：AllocationByteCount = " + bitmapReuse.getAllocationByteCount());

输出：
I/lz: bitmap = android.graphics.Bitmap@35ac9dd4
I/lz: width:1024:::height:594
I/lz: bitmap：ByteCount = 2433024:::bitmap：AllocationByteCount = 2433024
I/lz: bitmapReuse = android.graphics.Bitmap@35ac9dd4 // 两个对象的内存地址一致
I/lz: width:512:::height:297
I/lz: bitmap：ByteCount = 608256:::bitmap：AllocationByteCount = 2433024
I/lz: bitmapReuse：ByteCount = 608256:::bitmapReuse：AllocationByteCount = 2433024 // ByteCount比AllocationByteCount小
```

