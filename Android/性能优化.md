#### 1、如何进行屏幕适配。
- [常见屏幕适配方案](https://www.jianshu.com/p/55e0fca23b4f)
- [今日头条屏幕适配方案](https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA)

#### 2、ANR原理（回答主线程阻塞5秒不算，要分析源码）。
[ANR原理分析](http://gityuan.com/2016/07/02/android-anr/)
ANR(Application Not responding)，是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。    

 造成ANR的场景：
- Service Timeout:服务在20s内未执行完成；
- BroadcastQueue Timeout：比如前台广播在10s内执行完成
- ContentProvider Timeout：内容提供者执行超时
- InputDispatching Timeout: 输入事件分发超时5s，包括按键分发事件的超时。

#### 3、Java的四种引用，强弱软虚，及其适用的场景。
- 强引用：
   - 强引用可以直接访问目标对象。
   - 强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。
   - 强引用可能导致内存泄露。
- 软引用：
  - 在OutOfMemory异常发生之前，被占用的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。
  - 需要注意的是，在垃圾回收器对这个Java对象回收前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该Java对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。     
  
  - 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。
  - 还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。

- 弱引用：在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。但是，由于垃圾回收器的线程通常优先级很低，因此，并一不定能很快的发现持有弱引用的对象。这种情况下，弱引用对象可以存在较长的一段时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个注册引用队列中。 

  实际应用：播放器的播放Panel，是一个View，就是在视频播放时，可以show、hide, 也可以拖拽进度条之类，还有上面的音量，亮度调节等。这样一个view，我们用弱引用，因为在视频播放过程中，不论硬解还是软解，都将占用大量内存。

-  虚引用：
   - 虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。
   - 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，奖这个虚引用加入引用队列。
   
#### 4、常见的Android内存泄漏的场景，怎么解决。
- 单例造成的内存泄露。
- 匿名内部类/非静态内部类和异步线程。
```
	public class MainActivity extends AppCompatActivity {

        private static TestResource mResource = null;

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            if (mManager == null) {
                mManager = new TestResource();
            }
            //...
        }

        class TestResource {
            //...
        }
    }
```
   每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。

   正确的做法为：将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例。

- 匿名内部类：android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露。
- Handler 造成的内存泄漏。
- 集合类泄漏。

#### 5、怎么减小APK大小。
- 开启minifyEnable混淆代码。
- 开启shrinkResources去除无用资源。
- 删除未使用的xml和图片：使用Lint分析工具。
- 删除未使用的代码：使用Lint分析工具。
- 使用vector矢量图。
- 使用shape作为背景。
- 使用Tiny压缩图片。
- 配置resConfigs：如果APP支持中文`resConfigs "zh"`。
- 使用微信Android资源混淆工具。

#### 6、如何解决卡顿问题。
常见问题：
  - 过度绘制，层级过深。
  - 主线程耗时大的函数、滑动过程中的CPU工作问题。
   
    主线程里占用CUP时间很长的函数，特别关注IO操作（文件IO、网络IO、数据库操作等），
    主线程调用次数多的函数

工具：
  - Profile GPU Rendering（Profile GPU Rendering）
  - 设备过渡绘制查看功能、HierarchyViewer等
  - Lint静态代码分析工具
  - Traceview

#### 8、Android UI卡顿怎么进行监测。
 - [卡顿监测原理](https://blog.csdn.net/lmj623565791/article/details/58626355)     
 - [BlockCanary原理](http://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/)
 
 #### 8、Android UI卡顿怎么进行监测。
[卡顿监测原理](https://blog.csdn.net/lmj623565791/article/details/58626355)
[BlockCanary原理](http://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/)

1. 利用UI线程Looper打印的日志。
  - UI线程中的Looper，在其loop方法中会不断取出Message，调用其绑定的Handler在UI线程进行执行。
```
public static void loop() {
    final Looper me = myLooper();

    final MessageQueue queue = me.mQueue;
    // ...
    for (;;) {
        Message msg = queue.next(); // might block
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " +
                    msg.callback + ": " + msg.what);
        }
        // focus
        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }

        // ...
        }
        msg.recycleUnchecked();
    }
}
```
如果设置了logging，会分别打印出>>>>> Dispatching to和<<<<< Finished to这样的log。
```
public class BlockDetectByPrinter {

    public static void start() {

        Looper.getMainLooper().setMessageLogging(new Printer() {

            private long startTime;   
	    private long blockThreshold;
	    private long startedPrinting;

            @Override
            public void println(String x) {
                if (!startedPrinting) {
        		mStartTimeMillis = System.currentTimeMillis();
       			startedPrinting = SystemClock.currentThreadTimeMillis();
       			mStartedPrinting = true;
   		 } else {
        		final long endTime = System.currentTimeMillis();
        		startedPrinting = false;
			//判断是否为卡顿
       			if (isBlock(endTime)) {
			    StringBuilder sb = new StringBuilder();
        		    StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();
           			 for (StackTraceElement s : stackTrace) {
              				sb.append(s.toString() + "\n");
          			 }
       			}
    		}
            }
        });
    }
    
    private boolean isBlock(long endTime) {
   	 return endTime - startTime > blockThreshold;
    }
    
}
```
可以通过 `Looper.getMainLooper().setMessageLogging(mainLooperPrinter);`
并在mainLooperPrinter中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息。
