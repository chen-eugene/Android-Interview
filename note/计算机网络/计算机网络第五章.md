### 第五章：传输层

**要点：**

- 运输层为相互通信的应用进程提供逻辑通信。

- 端口和套接字的意义。

- 面向连接的TCP的特点。

- 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议。

- TCP的滑动窗口、流量控制、拥塞控制和连接管理。

#### 1、进程之间的通信

   从通信和信息处理的角度看，**运输层向它上面的应用提供通信服务**，它属于面向通信部分的最高层，同时也是用户功能中的最底层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。
    
   两台主机进行通信就是两台主机中的**应用进程互相通信**。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层，而没有交付主机中的应用进程。从运输层的角度看，**通信的真正端点并不是主机而是主机中的进程**。也就是说，端到端的通信是**应用进程之间的通信**。
   
   **网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信**。
   
   **运输层还要对收到的报文进行差错检测。网络层只对IP数据报首部进行擦错检测，不检查数据部分。**
   
#### 2、运输层的两个主要协议

   **用户数据报协议UDP(User Datagram Protocol)** ：UDP在传送数据之前**不需要先建立连接**。远程主机的运输层在收到UDP报文之后，不需要给出任何确认。虽然UDP不提供任何可靠交互，但在某些情况下UDP却是一种最有效的工作方式。
   
   **传输控制协议TCP(Transmission Control Protocol)** ：TCP则**提供面向连接的服务**。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器以及连接管理等。

#### 3、软件端口是应用层的各种协议与运输层进行交互的一种地址，区别于硬件端口，硬件端口时不同设备进行交互的接口。

   TCP/IP的运输层用一个16为端口号来标志一个端口。但请注意，**端口号只具有本地意义**，它只是为了标志本计算机应用层的进程在和运输层交互时的接口。在互联网不同计算机中，相同的款口号是没有关联的。
   
#### 4、UDP：只在IP的数据报服务之上增加了很少的一点功能，这就是服用和分用的功能以及差错检测的功能。

   - UDP是**无连接的**，即发送数据之前不需要建立连接，因此减少了开销和范松数据之前的时延。
   
   - UDP使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
   
   - UDP时**面向报文的**。即应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。
   
   - **UDP没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。
   
   - **UDP支持一对一、一对多、多对一和多对多的交互通信。**
   
   - **UDP的首部开销小**，只有8个字节，比TCP的20个字节的首部要短。
   
 #### 5、TCP的主要特点
 
   - TCP是**面向连接的运输层协议**。即应用程序在使用TCP协议之前，必须先建立TCP连接。在传输数据完毕之后，必须释放已经建立的TCP连接。
   
   - 每一条TCP连接只能有两个端点，没有条TCP连接只能是**点对点**。
   
   - TCP提供**可靠交付**的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。
   
   - TCP提供**全双工通信**。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。
   
   - **面向字节流**。TCP中的“流”指的是**流入到进程或从进程流程的字节序列**。
   
 #### 6、TCP把连接作为最基本的抽象。每一条TCP连接有两个端点。这个端点不是主机的IP地址，不是应用进程，也不是运输层的协议端口。TCP连接的端点叫做套接字(socket)[此套接字非彼套接字，套接字有多种含义]。
   
   **套接字socket = （IP地址：端口号）**
   
   ![常见的接口](https://github.com/chen-eugene/Interview/blob/master/image/sdgwerjktrreyjk.png)
   
#### 7、TCP首部

   - 确认号：占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。
   
     **若确认号 = N，则表明：到序号N-1为止的所有数据都已正确收到**
     
   - 确认ACK(ACKnowledgment)：仅当ACK = 1时确认号字段才有效。当ACK = 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段必须把ACK置1。
   
   - 同步SYN(SYNchronization)：在连接建立时用来同步序号。当SYN = 1而ACK = 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在相应的报文段中使SYN = 1和ACK = 1，因此，SYN置为1就表示这是一个连接请求或连接接受报文。
   
   - 终止FIN(FINis)：用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
   
   - 窗口：占2字节，是指从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。窗口值作为接收方让发送方设置其发送窗口的依据。
   
 #### 8、在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。
 
#### 9、TCP的运输连接管理

   运输连接有三个阶段：**连接建立**、 **数据传送**和**连接释放**。
   
   **连接建立**：TCP建立连接的过程叫做握手
   
   ![握手过程](https://github.com/chen-eugene/Interview/blob/master/image/1541818620(1).png) 
   
   - 最初两端的TCP进程都处于**CLOSED(关闭)** 状态。一开始，B的TCP服务器进程先创建**传输控制块TCB**，准备接受客户进程的连接请求。然后服务器进程处于**LISTEN(收听)** 状态，等待客户的连接请求。
   
   - A的TCP客户进程也是首先创建**传输控制模块TCB**。然后，在打算建立TCP连接时，向B发出连接请求报文段，这是首部中的同步位 **SYN = 1**，同时选择一个初始序号 seq = x。TCP规定，SYN报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这是TCP客户端进入 **SYN-SENT(同步已发送)** 状态。
   
   - B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack = x + 1，同时自己选择一个初始序号 seq = y。这个报文段也不能携带数据，但同时要消耗掉一个序号。这是TCP服务器进入 **SYN-RCVD(同步收到)** 状态。
   
   - A收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号 ack = y + 1，而自己的序号seq = x + 1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x + 1。这时，TCP连接已经建立，A进入**ESTABLISHED(已建立连接)** 状态。
   
   - 当B收到A的确认后，也进入**ESTABLISHED**状态。
   
#### 10、为什么A最后还要发送一次确认呢。

   **这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。**
   
   假定一种异常情况，即A发出的第一个连接请求报文段没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了。
   
   由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并以致等待A发来数据。B的许多资源就这样拜拜浪费了。
   
   采用三报文握手的办法，可以防止上述现象的发生。例如刚才的异常情况，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。
   
#### 11、TCP的连接释放

   ![挥手过程](https://github.com/chen-eugene/Interview/blob/master/image/1541818566(1).png)
   
   - 数据传输结束之后，通信双发都可以释放连接。现在A和B都处于**ESTABLISHED**状态。A的应用进程先向发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位**FIN**置1，其序号 seq = u，它等于前面遗传送过的数据的最后一个字节的序号加1。这时A进入**FIN-WAIT-1(终止等待1)**状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。
   
   - B收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是v，等于B前面已传送过的数据最后一个字节的序号加1.然后B就进入**CLOSED-WAIT(关闭等待)** 状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于**半关闭(half-close)** 状态，即A已经没有数据要求发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。
   
   - A收到来自B的确认后，就进入**FIN-WAIT-2(终止等待2)** 状态，等待B发出的连接释放报文段。
   
   - 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使 FIN = 1。现假定B的序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号 ack = u + 1。这时B就进入**LAST-ACK(最后确认)** 状态，等待A的确认。
   
   - A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把**ACK置1**，确认号 ack = w + 1，而自己的序号是 seq = u + 1。然后进入到**TIME-WAIT(时间等待)** 状态。请注意，现在TCP连接还没有释放掉。必须经过**时间等待计时器(TIME-WAIT timer)** 设置的时间**2MSL**后，A才进入到**CLOSED**状态。时间**MSL**叫做**最长报文段寿命(Maximum Segment Lifetime)** 。 当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。
   
   - B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。
   
#### 12、为什么A在TIME-WAIT状态必须等待2MSL的时间呢？

   - 为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在**LAST-ACK**状态的B收不到对已发送的**FIN + ACK**报文段的确认。B会超时重传这个**FIN + ACK**报文段，而A就能在**2MSL**时间内收到这个重传的FIN + ACK报文段。接着A重传一次确认，重新启动 2MSL 计时器。最后，A和B都正常进入到**CLOSED**状态。如果A在**TIME-WAIT**状态不等待一段时间，而是发送完ACK报文段后就立即释放连接，那么就无法收到B重传的FIN + ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。
   
   - 防止已失效的连接请求报文段出现在本连接中。A在发送完最后一个ACK报文段后，在经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。




   
